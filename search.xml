<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ç¨‹åºä¼˜åŒ–åˆè¯•]]></title>
    <url>%2Fpost%2F4b571416.html</url>
    <content type="text"><![CDATA[å…³äºç¨‹åºä¼˜åŒ–æˆ‘ä»¬å¹³æ—¶éƒ½å†™ç¨‹åºï¼Œä½†æ˜¯ä¸åŒçš„äººå†™å‡ºæ¥çš„ä»£ç è´¨é‡å´å‚å·®ä¸é½ï¼Œä»å¦‚ä¸‹å‡ æ–¹é¢è€ƒè™‘ï¼š ç¨‹åºçš„å¯æ‰©å±•æ€§ ç¨‹åºçš„å¥å£®æ€§ ç¨‹åºçš„æ€§èƒ½ ä»Šå¤©æˆ‘æ¥å°±æ¥è¯´ä¸€ä¸‹ç¨‹åºçš„æ€§èƒ½ã€‚ æœ€è¿‘åœ¨è¯»csapp(æ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿ),è¯»åˆ°ç¬¬äº”ç« çš„æ—¶å€™è§‰å¾—ä½œè€…å†™çš„å¾ˆæ£’ï¼Œ äºæ˜¯æ€»ç»“ä¸€ä¸‹ï¼Œåˆ†äº«ç»™å¤§å®¶ã€‚ é¦–å…ˆä»‹ç»ä¸€ä¸‹ç¨‹åºæ˜¯å¦‚ä½•åœ¨è®¡ç®—æœºä¸­è¿è¡Œçš„ï¼Œæˆ‘ä»¬ç¼–å†™çš„ä»£ç ï¼Œæœ€ç»ˆä¼šä»¥æœºå™¨ç åœ¨è®¡ç®—æœºä¸­è¿è¡Œã€‚ä»¥Cè¯­è¨€ä¸ºä¾‹ï¼Œ Cè¯­è¨€-&gt;ç¼–è¯‘å¾—åˆ°æ±‡ç¼–ä»£ç -&gt;ä¼˜åŒ–æ±‡ç¼–ä»£ç -&gt;æ±‡ç¼–ä»£ç ä¸ºç›®æ ‡æ–‡ä»¶-&gt;é“¾æ¥ç¨‹åºä¸ºå¯æ‰§è¡Œæ–‡ä»¶ æˆ‘ä»¬ä»Šå¤©ä¸»è¦å…³æ³¨å‰ä¸‰ä¸ªé˜¶æ®µï¼Œå‰ä¸‰ä¸ªé˜¶æ®µæ˜¯é¡ºåºçš„ï¼ŒCè¯­è¨€å†³å®šäº†æ±‡ç¼–ä»£ç é•¿ä»€ä¹ˆæ ·å­ï¼Œæ±‡ç¼–ä»£ç å†³å®šäº†èƒ½å¦è¢«ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œå› æ­¤Cè¯­è¨€çš„å†™æ³•å°±æ˜¾å¾—å°¤ä¸ºé‡è¦äº†ã€‚ æˆ‘ä»¬ç°åœ¨ä¸»è¦ä»‹ç»ä¸€ä¸‹ä¹¦ä¸­è¯´çš„é›†ä¸­ä¼˜åŒ– æ¶ˆé™¤ä½æ•ˆç‡å¾ªç¯è¯•æƒ³ï¼Œæœ‰å¦‚ä¸‹å‡½æ•°ï¼š 12345int test(char* c)&#123; for(int i = 0; i &lt; strlen(c); i++)&#123; //do something &#125;&#125; å¤§å®¶æƒ³ä¸€æƒ³ï¼Œä¸Šé¢çš„ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜å—ï¼Ÿ 12345678910LBB0_2: ## =&gt;This Inner Loop Header: Depth=1 xorl %eax, %eax movq %r14, %rdi movl %ebx, %esi callq _printf incq %rbx movq %r15, %rdi callq _strlen cmpq %rbx, %rax ja LBB0_2 ä¸Šå›¾æ˜¯ä»£ç è¢«ç¼–è¯‘æˆæ±‡ç¼–è¯­è¨€ä¹‹åçš„å…³äºå¾ªç¯çš„ä¸€éƒ¨åˆ†ï¼Œä»ä¸­å¯ä»¥çœ‹åˆ° cmpqä¹‹åä¼šå†æ¬¡è·³è½¬åˆ°LLB0_2 ï¼Œè€ŒLLB0_2 ä¼šå†æ¬¡callq _strlenï¼Œcallä»£ä»·å¾ˆé«˜ï¼Œæ‰€ä»¥æˆ‘ä»¬é’ˆå¯¹è¿™ä¸€ç‚¹å¯¹ä¸Šè¿°ç¨‹åºè¿›è¡Œä¼˜åŒ–ï¼Œ 123456int test(char* c)&#123; int length = strlen(c) for(int i = 0; i &lt; length; i++)&#123; //do something &#125;&#125; ä¸Šè¿°ä»£ç çš„call _strlenè¢«æŒªåˆ°äº†å¾ªç¯å¤–é¢ï¼Œæé«˜äº†ç¨‹åºæ€§èƒ½ã€‚ æ¶ˆé™¤ä¸å¿…è¦çš„å†…å­˜å¼•ç”¨å†…å­˜å¼•ç”¨éœ€è¦å¯»å€ï¼Œ å†…å­˜è™½ç„¶æ¯”å¤–éƒ¨IOå¿«å¾ˆå¤šï¼Œä½†æ˜¯ç›¸å¯¹äºCPUå†…çš„å¯„å­˜å™¨æ¥è¯´è¿˜æ˜¯è¦æ…¢å¾ˆå¤šçš„ã€‚æ‰€ä»¥è¦å°½é‡å‡å°‘ç¨‹åºä¸­ä¸åˆç†çš„å†…å­˜å¼•ç”¨ã€‚è€ƒè™‘å¦‚ä¸‹ä»£ç : 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt;int test(int* dest, int n)&#123; for(int i = 0; i &lt; n; i++)&#123; //do something *dest = *dest + 100; &#125; return 0;&#125; ä¸Šé¢çš„ä»£ç çœ‹èµ·æ¥é€»è¾‘ä¸Šæ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œä½†æ˜¯æˆ‘ä»¬ä»”ç»†æ€è€ƒä¸€ä¸‹cä»£ç ä¸‹é¢çš„è¿è¡Œé€»è¾‘ï¼š cæŒ‡é’ˆæœ¬è´¨ä¸Šæ˜¯è¿›è¡Œä¸€æ¬¡å†…å­˜å¯»å€ï¼Œä¸Šé¢å’±ä»¬ä¹Ÿè¯´è¿‡å†…å­˜å¯»å€ç›¸å¯¹äºå¯„å­˜å™¨æ¥è¯´å¤ªæ…¢äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°ä»£ç ä¼˜åŒ–ä¸€ä¸‹ï¼š 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int test(int* dest, int n)&#123; int acc = *dest; for(int i = 0; i &lt; n; i++)&#123; //do something acc = acc + 100; &#125; *dest = acc; return 0;&#125; ç»è¿‡è¿™ä¹ˆæ”¹é€ ï¼Œ å°†å¯¹å†…å­˜çš„å¼•ç”¨ç§»åˆ°äº†å¾ªç¯å¤–éƒ¨ï¼Œ å¦‚æœnå¾ˆå¤§çš„è¯ï¼Œå¯¹æ€§èƒ½æå‡æ¥è¯´è¿˜æ˜¯å¾ˆå¥½çš„ã€‚]]></content>
      <tags>
        <tag>ç¨‹åºä¼˜åŒ– csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arts-04-07]]></title>
    <url>%2Fpost%2Fc4543e60.html</url>
    <content type="text"><![CDATA[ç¬¬å››å‘¨è¿™å‘¨ç®€ç›´å¿™ç‚¸ï¼Œä½†æ˜¯è¿˜æ˜¯ä¸èƒ½æ”¾å¼ƒå­¦ä¹ æ»´~ æ¥ä¸‹æ¥ æˆ‘ä»¬è¿›è¡Œè¿™å‘¨çš„ arts å•¦~ï¼ Review goLang Totorialæœ¬å‘¨å­¦ä¹ çš„æ˜¯ Go çš„å¸¸é‡ã€‚å¸¸é‡å°±åƒæ˜¯çŸ³å¤´é‡Œè¹¦å‡ºæ¥çš„å­™æ‚Ÿç©ºï¼Œä¸€æƒŠå‡ºä¸–å°±ä¸å¯å†æ”¹å˜äº†ï¼Œå¤´é“çš„å¾ˆã€‚ 123456789101112package mainimport ( "fmt" "math")func main() &#123; fmt.Println("Hello, playground") var a = math.Sqrt(4)//allowed const b = math.Sqrt(4)//not allowed&#125; è¿˜æœ‰éœ€è¦æ³¨æ„çš„ä¸€ç‚¹äº‹ (å¸¸é‡)constant å¿…é¡»æ˜¯åœ¨ç¼–è¯‘å™¨å°±è¢«ç¡®å®šçš„,å› æ­¤ä¸Šè¿°å¯¹å¸¸é‡è¿›è¡Œå‡½æ•°èµ‹å€¼æ˜¯ä¸å…è®¸çš„ æˆ‘ä»¬çŸ¥é“ go æ˜¯å¼ºç±»å‹è¯­è¨€ï¼Œé‚£ä¹ˆå¦‚ä¸‹ 1const a = "test" a æ˜¯ä»€ä¹ˆç±»å‹å‘¢ï¼Ÿ ç­”æ¡ˆæ¯ä¸ª constant éƒ½æœ‰ä¸€ä¸ªé»˜è®¤çš„ç±»å‹,è¿™å’Œå®ƒçš„å€¼æœ‰å…³ç³»ã€‚å½“ä»–è¢«ç”¨åˆ°çš„æ—¶å€™ï¼Œä¼šé€šè¿‡è‡ªèº«çš„å€¼è½¬åŒ–ä¸ºå¯¹åº”çš„ç±»å‹(å¦‚æœå¯ä»¥è½¬åŒ–çš„è¯) AlgorithmMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. è¿™é“é¢˜ tip æ˜¯åˆå§‹åŒ–ä¸€ä¸ª-1 çš„ Node éå†å®Œä¹‹åå†å»æ‰å°± ok äº† 1234567891011121314151617181920212223242526272829303132class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode p = l1, q = l2; ListNode res = new ListNode(-1); ListNode ret = res; ret = res; while (p != null &amp;&amp; q != null) &#123; if (p.val &lt;= q.val) &#123; res.next = new ListNode(p.val); p = p.next; &#125;else&#123; res.next = new ListNode(q.val); q = q.next; &#125; res = res.next; &#125; while(p != null)&#123; res.next = new ListNode(p.val); p = p.next; res = res.next; &#125; while(q != null)&#123; res.next = new ListNode(q.val); q = q.next; res = res.next; &#125; ret = ret.next; return ret; &#125;&#125; Sã€Šç‹è€…è£è€€ã€‹æŠ€æœ¯æ€»ç›‘å¤ç›˜å›ç‚‰å†ç¨‹è®²äº†ç‹è€…è£è€€æˆé•¿è¿‡ç¨‹ä¸­çš„ä¸€äº›å†ç¨‹ï¼Œ å¾ˆæœ‰å¯å‘æ€§ã€‚]]></content>
      <categories>
        <category>[object Object]</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[è…¾è®¯äº‘æœåŠ¡å™¨çš„å‘-iptables]]></title>
    <url>%2Fpost%2F85230e64.html</url>
    <content type="text"><![CDATA[è…¾è®¯äº‘æœåŠ¡å™¨çš„å‘-iptablesiptables æ²¡æ³•åŠ è½½ nat æ¨¡å—ä»Šå¤©å®‰è£… docker çš„æ—¶å€™å‘ç°å¯åŠ¨å¤±è´¥ï¼Œ journalctl -u docker.service å‘ç°æ— æ³•é€šè¿‡ iptables è®¾ç½® nat google ä¹‹åå‘ç°è¿™ä½å¤§ä½¬ä¹Ÿé‡åˆ°äº†è¿™ä¸ªé—®é¢˜ï¼Œ æœ‰å¯èƒ½æ˜¯å› ä¸º linux ç¦ç”¨äº†ä¸€äº›ç³»ç»Ÿæ¨¡å— Docker å®‰è£…æŒ‡å—ä»¥åŠä½¿ç”¨ GPU è¯¦ç»†ç»†èŠ‚å¯ä»¥çœ‹å¤§ä½¬çš„æ–‡ç«  123/etc/modprobe.d/blacklist.conf/etc/modprobe.d/connectiontracking.conf è¿™ä¸¤ä¸ªæ–‡ä»¶å°±æ˜¯æ¨¡å—é»‘åå•ï¼Œå»æ‰å¯¹åº”çš„ mod å³å¯]]></content>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arts-04-01]]></title>
    <url>%2Fpost%2F2d379b55.html</url>
    <content type="text"><![CDATA[third artsR golang å­¦ä¹ è¿™ä¸€èŠ‚æˆ‘ä»¬å­¦ä¹  golang çš„åŸºæœ¬ç±»å‹ bool ç±»å‹ æ•°å€¼ç±»å‹ å­—ç¬¦ä¸²ç±»å‹ bool ç±»å‹å’Œåˆ«çš„ç¼–ç¨‹è¯­è¨€ä¸­çš„ä¸€æ ·ï¼Œæœ‰true å’Œ falseä¸¤ç§ 123456789101112package mainimport "fmt"fun main() &#123; a:=true b:=false //c ä¸º trhe c:= a || b //d ä¸ºfalse d:= a &amp;&amp; b&#125; æ•´å‹æ•°å­—ç±»å‹å’Œä»–ä»¬å¯ä»¥è¡¨ç¤ºçš„èŒƒå›´ä¸º int8: -127~128 int16: -32768~32767 int32: -2147483648~2147483647 int64: -9223372036854775808~9223372036854775807 int: æ ¹æ®æ“ä½œç³»ç»Ÿä¸åŒä¼šä»£è¡¨ int32 æˆ–è€… int64 åœ¨ä¸Šè¿°æ•°å€¼ç±»å‹å‰é¢åŠ uå¦‚uint8å¯ä»¥è¡¨ç¤ºæ— ç¬¦å·æ•° æµ®ç‚¹å‹æ•°å­—ç±»å‹æœ‰: float32 float64 go è¿˜å¯ä»¥è¡¨ç¤ºå¤æ•°ç±»å‹: complex64 complex128 1c := 6 + 7i è¿˜æœ‰ä¸¤ä¸ªæ•°å€¼ç±»å‹ byte å’Œ rune åˆ†åˆ«æ˜¯ uint8 å’Œ int32çš„åˆ«ç§° å­—ç¬¦ä¸²ç±»å‹ å­—ç¬¦ä¸²ç±»å‹å¯ä»¥çœ‹æˆæ˜¯è¿ç»­çš„byte æœ¬æ–‡è¿˜ä»‹ç»äº†å…³äºç±»å‹è½¬æ¢çš„ä¸€äº›é—®é¢˜,go ä¸ä¼šè¿›è¡Œéšå¼çš„ç±»å‹è½¬æ¢ï¼Œå¿…é¡»æœ‰æ˜¾å¼(explicit)çš„ç±»å‹è½¬æ¢ã€‚ æœ¬æ¬¡çš„ golang å­¦ä¹ åˆ°æ­¤ç»“æŸï¼Œ æœŸå¾…ä¸‹å‘¨~ï¼ ALongest Substring Without Repeating Characters è¿™é“é¢˜ç»è¿‡ä»”ç»†çš„æ€è€ƒï¼Œå‘ç°äº†æ¯”è¾ƒå¥½çš„æ€è·¯ 12345678910111213class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int[] m = new int[256]; Arrays.fill(m, -1); int res = 0, left = -1; for (int i = 0; i &lt; s.length(); i++) &#123; left = Math.max(left, m[s.charAt(i)]); m[s.charAt(i)] = i; res = Math.max(res, i - left); &#125; return res; &#125;&#125; æ€è·¯æ˜¯ç”¨ä¸€ä¸ª 256 çš„ int æ•°ç»„æ¥è¡¨ç¤º Characterï¼Œç„¶åä»å·¦åˆ°å³èµ°ä¸€éString s è¿‡ç¨‹ä¸­æ‰¾æœ€è¿œçš„è·ç¦»æ—¶é—´å¤æ‚åº¦æ˜¯ O(n), ç©ºé—´å¤æ‚åº¦ä¸ºå¸¸é‡ O(1) Tè¿™å‘¨å­¦ä¹ åˆ°ä¸€ä¸ªå…³äº javascript çš„å°æŠ€å·§ 123456789101112// æ‰“å°å‡½æ•°è¿è¡Œæ—¶é—´const slowFunction = number =&gt; &#123; console.time("slowFunction"); console.timeEnd("slowFunction");&#125;;console.time();for (i = 0; i &lt; 100000; ++i) &#123; slowFunction(i);&#125;console.timeEnd(); å¯ä»¥æ£€æµ‹å‡ºæ¥å¾ªç¯æ¯ä¸€æ­¥è¿è¡Œäº†å¤šé•¿æ—¶é—´]]></content>
      <categories>
        <category>[object Object]</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java LinkedList]]></title>
    <url>%2Fpost%2F5e9e4bd.html</url>
    <content type="text"><![CDATA[java Linked List æºç å­¦ä¹ å˜¿å˜¿ï¼Œå…¶å®æœ€è¿‘ä¸€ç›´åœ¨çœ‹javaç›¸å…³çš„ä¸œè¥¿ï¼Œä¸Šä¸‹ç­é€šå‹¤çš„æ—¶å€™å†çœ‹ç‹äº‰è€å¸ˆçš„æ•°æ®ç»“æ„ï¼Œæ­£å¥½çœ‹åˆ°é“¾è¡¨è¿™ä¸€ç« ï¼Œå°±è‡ªå·±å®ç°äº†ä¸€ä¸‹é“¾è¡¨ã€‚ å®Œäº†åˆå»çœ‹äº†ä¸€ä¸‹jdkå¯¹é“¾è¡¨çš„å®ç°ã€‚å‘ç°javaå¯¹é“¾è¡¨çš„å®ç°è¿˜æ˜¯æŒºä¼˜é›…çš„ã€‚é€šè¿‡æ¥å£ï¼Œå¯ä»¥è®©å®ç°çš„é“¾è¡¨æ‰©å±•å…¶ä»–åŠŸèƒ½ï¼Œæ¯”å¦‚Dequeç­‰ javaçš„é“¾è¡¨ç»§æ‰¿äºAbstractSequentialList å¹¶å®ç°äº† List Deque Clonable java.io.Serializable æ¥å£ æä¾›ä¸¤ä¸ªæ„é€ å‡½æ•°ï¼Œé»˜è®¤çš„æ„é€ å‡½æ•°å’Œä¸€ä¸ªæ¥å—Collection &lt;? extends E&gt;çš„æ„é€ å‡½æ•° Collection &lt;? extends E&gt;çš„æ„é€ å‡½æ•°å†…éƒ¨è°ƒç”¨äº†addAllæ–¹æ³•æ¥è¿›è¡Œé“¾è¡¨çš„åˆå§‹åŒ– å¦‚ä¸‹æ˜¯java addAllçš„ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int newNum = a.length; if (newNum == 0) &#123; return false; &#125; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) &#123; first = newNode; &#125; else &#123; pred.next = newNode; &#125; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += newNum; modCount++; return true;&#125; LinkListæä¾›äº†linkFirst linkLast LinkBefore æ¥ä¾›LinkListè¿›è¡Œå†…éƒ¨çš„ä¿®æ”¹ å¯¹LinkListè¿›è¡Œæ·»åŠ æ“ä½œçš„æœ‰ add push å®ƒä¿©éƒ½æ˜¯å¯¹addFirstçš„è°ƒç”¨ï¼Œ 2ï¸è€ŒaddFirstæ˜¯å¯¹LinkFirstçš„è°ƒç”¨, LinkFirstä»£ç å¦‚ä¸‹ 1234567891011121314private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) &#123; //è€ƒè™‘é“¾è¡¨ä¸ºç©ºçš„æƒ…å†µ last = newNode; &#125; else &#123; f.prev = newNode; &#125; size++; modCount++;&#125; åˆ é™¤çš„æ“ä½œå’Œæ·»åŠ ç±»ä¼¼ï¼Œåœ¨æ­¤ä¸åšèµ˜è¿°ã€‚ å¯ä»¥æ‰“å¼€jdkæºç æ¥çœ‹ä¸€ä¸‹ï¼Œéƒ½å¾ˆç®€å•ã€‚ è¿˜æœ‰å€¼å¾—ä¸€æçš„æ˜¯LinkedListé‡Œé¢æœ‰ä¸€ä¸ªç§æœ‰ç±»ListItrç”¨äºå¯¹LinkedListçš„éå†ï¼Œ ListItr å®ç°äº† ListIteratoræ¥å£ï¼Œå¯ä»¥æ–¹ä¾¿çš„å¯¹LinkedListè¿›è¡Œéå†]]></content>
  </entry>
  <entry>
    <title><![CDATA[arts_03_25]]></title>
    <url>%2Fpost%2F94241583.html</url>
    <content type="text"><![CDATA[arts second weekRThis week, letâ€™s learn some basic syntax about go! First of all, weâ€™ll talk about variable of go. Variable is a pointer (or a name) given to a memory location. You can define a variable just like below. 1var age int int means that age is an integer variable.or you can omit the type word if you initial the variable like below.1var age = 15 go will know that age is type of int, the other way to define a variable is: 1age := 15 This way, you can declare and initial variable by only on line. Multiple variable declaration: you can declare multiple variable.1234567891011var age, height intvar h, w = 100, 50var( age int x = 1 str = "string")name, z := "string", 30 A1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head.next == null) return null; ListNode p = head; ListNode flag = head; for(; n&gt;0; n--)&#123; p = p.next; &#125; if(p == null) return head.next; while(p.next != null)&#123; p = p.next; flag = flag.next; &#125; flag.next = flag.next.next; return head; &#125;&#125; TIâ€™m using markdown recently, and I found an issue that I must go one pic Bed to upload one pic and then I got the link of the pic. This is a terrible experience. So I found One Big guy â€“ PicGo. The software is saviour.Pictures in this post is generate by PicGo! SThis week learn java LinkedList~! java LinkedList]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java å…¥é—¨ -- åŸºæœ¬ç¨‹åºè®¾è®¡]]></title>
    <url>%2Fpost%2Ff1ba796c.html</url>
    <content type="text"><![CDATA[Java å…¥é—¨ â€“ åŸºæœ¬ç¨‹åºè®¾è®¡javaç¨‹åºåŸºäºç±»ã€‚ä¸€ä¸ªåŸºç¡€çš„javaç¨‹åºå¦‚ä¸‹:12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World"); &#125;&#125; ä»¥ä¸Šå°±æ˜¯ä¸€ä¸ªç®€å•çš„Javaç¨‹åºã€‚å¾ˆç®€å•~ ğŸŒ Javaæ˜¯å¼ºç±»å‹è¯­è¨€ï¼Œæ‰€ä»¥åœ¨å£°æ˜å˜é‡çš„æ—¶å€™éœ€è¦æŒ‡å®šå˜é‡çš„ç±»å‹ã€‚ Javaæ•°å€¼ç±»å‹javaçš„æ•°å€¼ç±»å‹æœ‰å¦‚ä¸‹å‡ ç§ç±»å‹:(å›¾ç‰‡æ‘˜è‡ªã€ŠJavaç¨‹åºè®¾è®¡ã€‹) ä¹¦ä¸­ä¸€ä¸ªè®¡ç®—åˆ†ç§’çš„å°ç¨‹åº12345678910111213141516171819202122package chapter.one;import java.util.Scanner;/** * * @author zrb */public class Welcome &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.print("è¯·è¾“å…¥ç§’æ•°ï¼š"); Integer second = input.nextInt(); Integer minute = second / 60; Integer secondLeft = second % 60; System.out.println("å¯¹åº”çš„åˆ†ç§’æ•°ä¸ºï¼š " + minute + "åˆ†" + secondLeft + "ç§’"); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>javaè¯­è¨€ç¨‹åºè®¾è®¡</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[arts_03_18]]></title>
    <url>%2Fpost%2Fc1b83afd.html</url>
    <content type="text"><![CDATA[goal 1A add two numbers 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ret = new ListNode(0); ListNode res = ret; ListNode p1 = l1; ListNode p2 = l2; int flag = 0; while(p1 != null &amp;&amp; p2 != null)&#123; res.val = p1.val + p2.val; if(flag == 1)&#123; res.val = res.val + 1; flag = 0; &#125; if(res.val &gt;= 10)&#123; res.val = res.val - 10; flag = 1; &#125; if(p1.next != null || p2.next != null || flag == 1 )&#123; res.next = new ListNode(0); res = res.next; &#125; p1 = p1.next; p2 = p2.next; &#125; if(flag == 1)&#123; res.val = 1; flag = 0; &#125; while(p1 != null)&#123; res.val = p1.val + res.val; if(res.val &gt;= 10)&#123; res.val = res.val -10; flag = 1; &#125; if(p1.next != null || flag == 1)&#123; res.next = new ListNode(0); res = res.next; if(flag == 1)&#123; res.val = 1; flag = 0; &#125; &#125; p1 = p1.next; &#125; while(p2 != null)&#123; res.val = p2.val + res.val; if(res.val &gt;= 10)&#123; res.val = res.val -10; flag = 1; &#125; if(p2.next != null || flag == 1)&#123; res.next = new ListNode(0); res = res.next; if(flag == 1)&#123; res.val = 1; flag = 0; &#125; &#125; p2 = p2.next; &#125; return ret; &#125;&#125; è¿™ä¸ªé¢˜ç›®æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯åšçš„æ—¶å€™è¿˜æ˜¯æœ‰äº›æƒ…å†µæ²¡æœ‰è€ƒè™‘åˆ°ï¼Œæœ‰å¦‚ä¸‹å‡ ç‚¹: åœ¨ç¬¬ä¸€æ¬¡åŒæ­¥éå†å®Œä¸¤æ¡é“¾è¡¨çš„æ—¶å€™ï¼Œä¹‹åæ²¡æœ‰è€ƒè™‘æœ€åä¸€æ¬¡å¦‚æœè¿›ä½çš„æƒ…å†µ æ²¡æœ‰è€ƒè™‘å•æ¡éå†æœ€åä¸€æ­¥çš„è¿›ä½æƒ…å†µ å¾—åˆ°æ•™è®­ï¼Œä»¥ååšé¢˜çš„æ—¶å€™è¿˜æ˜¯å…ˆæŠŠé¢˜ç›®ä»”ç»†æƒ³ä¸€éå†åŠ¨æ‰‹ï¼Œæœ€å¥½ç”»å‡ºæ¥ã€‚ R goè¯­è¨€ä»‹ç»ä¸hello worldgo tutorialè¿™ä¸€ç³»åˆ—ä»‹ç»äº†go ä»€ä¹ˆæ˜¯gogoæ˜¯googleæ¨å‡ºä¸€ç§é™æ€å¼ºç±»å‹çš„ç¼–è¯‘å‹è¯­è¨€ã€‚ ä¸ºä½•é€‰æ‹©go?: å¤©ç”Ÿæ”¯æŒå¹¶å‘, ç¼–å†™å¹¶å‘å¾ˆç®€å•, goé€šè¿‡Goroutineså’Œchannelsæ¥å®Œæˆå¹¶å‘ goæ˜¯ç¼–è¯‘å‹è¯­è¨€ï¼Œæºç ä¼šè¢«ç¼–è¯‘æˆæœºå™¨ç è¿è¡Œï¼Œæ•ˆç‡æ¯”è§£é‡Šæ€§è¯­è¨€é«˜å¾ˆå¤šã€‚ goæ–‡æ¡£ç®€å• goç¼–è¯‘å™¨æ”¯æŒé™æ€é“¾æ¥,æ‰€æœ‰ä¾èµ–åº“éƒ½ä¼šè¢«é“¾æ¥åˆ°ä¸ºä¸€ä¸ªäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ï¼Œéƒ¨ç½²æ–¹ä¾¿ï¼Œç§»æ¤æ€§ä¹Ÿè¿˜ä¸é”™ã€‚ å®‰è£…å®‰è£…åœ°å€ æŒ‰ç…§æ­¥éª¤ä¸€æ­¥ä¸€æ­¥å®‰è£…çš„ ä»¥ä¸Šå°±æ˜¯è¿™ç¯‡æ–‡ç« çš„æ€»ç»“~ T tips å‘ç°äº†oh-my-zsh çš„ä¸€ä¸ªå¥½ç”¨çš„æ’ä»¶ autojump ï¼ åŒæ ·ä½œç”¨çš„æ’ä»¶è¿˜æœ‰â€™zâ€™ å¾ˆå¥½ç”¨ï¼Œä½œç”¨æ˜¯å¯ä»¥å¿«æ·çš„è·³è½¬åˆ°æ›¾ç»cdè¿‡çš„ç›®å½• æˆªå›¾å¦‚ä¸‹ Så¼€å¯æˆ‘çš„javaå­¦ä¹ ä¹‹æ—…~Java å…¥é—¨ â€“ åŸºæœ¬ç¨‹åºè®¾è®¡]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis-zskiplist - å¸¦ä½ ææ‡‚redis]]></title>
    <url>%2Fpost%2F27c5a942.html</url>
    <content type="text"><![CDATA[skiplistè·³è·ƒè¡¨æœ‰ä¸¤ä¸ªå…³é”®çš„ç»“æ„skiplistå’ŒskiplistNode skiplist è®°å½•äº†è·³è·ƒè¡¨é‡Œé¢åŒ…å«èŠ‚ç‚¹çš„æ•°é‡ï¼ŒskiplistNodeåŒ…å«äº†æ¯ä¸ªèŠ‚ç‚¹çš„å±‚æ•° zslCreate12345678910111213141516171819202122232425zskiplist *zslCreate(void) &#123; int j; zskiplist *zsl; // åˆ†é…ç©ºé—´ zsl = zmalloc(sizeof(*zsl)); // è®¾ç½®é«˜åº¦å’Œèµ·å§‹å±‚æ•° zsl-&gt;level = 1; zsl-&gt;length = 0; // åˆå§‹åŒ–è¡¨å¤´èŠ‚ç‚¹ // T = O(1) zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL); for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123; zsl-&gt;header-&gt;level[j].forward = NULL; zsl-&gt;header-&gt;level[j].span = 0; &#125; zsl-&gt;header-&gt;backward = NULL; // è®¾ç½®è¡¨å°¾ zsl-&gt;tail = NULL; return zsl;&#125; 1234567891011zskiplistNode *zslCreateNode(int level, double score, robj *obj) &#123; // åˆ†é…ç©ºé—´ zskiplistNode *zn = zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel)); // è®¾ç½®å±æ€§ zn-&gt;score = score; zn-&gt;obj = obj; return zn;&#125; zslCreateNodeåˆ›å»ºäº†ä¸€ä¸ªzskiplistNodeå¹¶è¿›è¡Œäº†åˆå§‹åŒ– æœªå®Œå¾…ç»­]]></content>
      <categories>
        <category>redis</category>
        <category>å¸¦ä½ ææ‡‚redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rediså­—å…¸è¯¦è§£ - å¸¦ä½ ææ‡‚redis]]></title>
    <url>%2Fpost%2F278b8e98.html</url>
    <content type="text"><![CDATA[å­—å…¸ç»“æ„å­—å…¸çš„ç»“æ„å¦‚å›¾æ‰€ç¤º ä¸€ä¸ªå­—å…¸ç»“æ„(dict)é‡Œé¢è®°å½•äº†dictType,æœ‰ä¸¤ä¸ªå“ˆå¸Œè¡¨(ä¸ºäº†rehash)ï¼Œrehashidxè®°å½•äº†å½“å‰rehashçš„è¿›åº¦ dictEntryç»“æ„dictEntry ç»“æ„å†…åŒ…å«: key v next key å‚¨å­˜äº†é”®ï¼Œ vå‚¨å­˜äº†å€¼ï¼Œvçš„ç»“æ„å¦‚ä¸‹æ‰€ç¤ºï¼Œvå¯ä»¥å‚¨å­˜ä¸€ä¸ªæŒ‡é’ˆã€ä¸€ä¸ªuint64_tçš„æ•°ï¼Œæˆ–è€…ä¸€ä¸ªint64_tçš„å€¼, nextåˆ™æ˜¯ä¸ºäº†è§£å†³hashå†²çªæŒ‡å‘ä¸‹ä¸€ä¸ªå…·æœ‰ç›¸åŒhashå€¼çš„å®ä½“èŠ‚ç‚¹ 12345union &#123; void *val; uint64_t u64; int64_t s64; &#125; v; dictht ç»“æ„dicthtç»“æ„å†…åŒ…å«: table size sizemask used tableæ˜¯ä¸€ä¸ªdictEntryçš„æ•°ç»„ï¼Œsizeè®°å½•äº†tableæ•°ç»„çš„å¤§å°ï¼Œsizemaskä¸ºå“ˆå¸Œè¡¨å¤§å°æ©ç ä¸ºsize-1ï¼Œusedè®°å½•äº†tableä¸­å·²æœ‰èŠ‚ç‚¹çš„æ•°é‡ dictType ç»“æ„dictType ç»“æ„åŒ…å«: dictTypeé‡Œé¢åŒ…å«äº†é’ˆå¯¹dictç±»å‹çš„ç‰¹å®šçš„æ“ä½œå‡½æ•°ï¼Œå¦‚hashè®¡ç®—å‡½æ•°(hashFunction)ï¼Œé”®å¤åˆ¶å‡½æ•°(keyDup)ç­‰ç­‰. dict ç»“æ„dictæ˜¯å­—å…¸çš„æ•°æ®ç»“æ„ï¼ŒdictåŒ…å«: type privdata dictht[2] rehashidx iterators typeå®šä¹‰äº†dictçš„ç±»å‹(æ“ä½œdictçš„ä¸€ç³»åˆ—æ–¹æ³•) privdataæ˜¯dictçš„ä¸€äº›ç§æœ‰æ•°æ®(ç”¨æ¥ç»™ç‰¹å®šçš„ç±»å‹ç‰¹å®šå‡½æ•°çš„å¯é€‰å‚æ•°) dicthtæ˜¯å­—å…¸å“ˆå¸Œè¡¨ï¼Œæœ‰ä¸¤ä¸ªæ˜¯ä¸ºäº†è¿›è¡Œrehash rehashidxè®°å½•äº†rehashè¿›åº¦,å½“å‰æ²¡æœ‰è¿›è¡Œrehashçš„æ—¶å€™ä¸º-1 iteratorsæ˜¯å½“å‰å­—å…¸æ­£åœ¨è¿è¡Œçš„å®‰å…¨è¿­ä»£å™¨çš„æ•°é‡ å­—å…¸å…ƒç´ æ·»åŠ è¿‡ç¨‹è§£æå‘å­—å…¸ä¸­åŠ å…¥å…ƒç´ çš„è¿‡ç¨‹å‘å­—å…¸ä¸­åŠ å…¥å…ƒç´ çš„è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ·»åŠ è¿‡ç¨‹ä¸­å‡ºç°é”®å†²çªï¼Ÿå¦‚æœåœ¨ä¸Šè¿°è¿‡ç¨‹ä¸­è®¡ç®—å‡ºçš„indexåœ¨å¯¹åº”çš„htçš„tableä¸­å·²ç»æœ‰å…ƒç´ äº†ï¼Œredisæ­¤æ—¶ä¼šåœ¨è¯¥å…ƒç´ å‰é¢æ’å…¥ä¸€ä¸ªå…ƒç´ å®ä½“é”®å€¼ä¸ºè¦æ’å…¥çš„é”®å€¼. å­—å…¸rehashå­—å…¸rehashè¿‡ç¨‹å­—å…¸ä¼šè®©æœ¬èº«çš„è´Ÿè½½å› å­(used/size)ç»´æŒåœ¨ä¸€ä¸ªåˆç†çš„å€¼ï¼Œå¦‚æœè´Ÿè½½å› å­è¿‡å¤§ï¼Œä¼šé™ä½å­—å…¸çš„æ•ˆç‡ï¼Œè¿‡å°ä¼šæµªè´¹å®è´µå†…å­˜ç©ºé—´ã€‚ å­—æ®µé€šè¿‡rehashæ¥ä¿æŒè´Ÿè½½å› å­åˆç†ï¼Œè¿‡ç¨‹å¦‚ä¸‹ ä¸ºdictçš„ht[1]åˆ†é…ç©ºé—´ï¼Œå¦‚æœæ˜¯æ‰©å¤§æ“ä½œï¼Œåˆ†é…çš„ç©ºé—´å¤§å°ä¸ºç¬¬ä¸€ä¸ªå¤§äºht[0].used*2çš„2^nçš„å€¼ï¼Œå¦‚æœæ˜¯æ”¶ç¼©æ“ä½œï¼Œå¤§å°ä¸ºç¬¬ä¸€ä¸ªå¤§äºht[0].usedçš„2^nçš„å€¼ å°†ht[0]æ‰€æœ‰é”®å€¼å¯¹rehashåˆ°ht[1] é‡Šæ”¾ht[0],å°†ht[1]è®¾ç½®ä¸ºht[0],å¹¶åœ¨ht[1]åˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºå“ˆå¸Œè¡¨ è§¦å‘å­—å…¸rehashçš„æ¡ä»¶ å­—å…¸çš„è´Ÿè½½å› å­å¤§äºç­‰äº1å¹¶ä¸”æœåŠ¡å™¨æ²¡æœ‰åœ¨æ‰§è¡ŒBGSAVEæˆ–è€…BGREWITEAOF å­—å…¸çš„è´Ÿè½½å› å­å¤§äº5å¹¶ä¸”æœåŠ¡å™¨åœ¨æ‰§è¡ŒBGSAVEæˆ–è€…BGREWITEAOF å­—å…¸è´Ÿè½½å› å­å°äº0.1ï¼Œä¼šæ‰§è¡Œæ”¶ç¼©æ“ä½œ dictæ¸è¿›å¼rehashrehashä¸æ˜¯ä¸€æ¬¡æ€§å®Œæˆçš„ï¼Œåœ¨rehashçš„æ—¶å€™å­—å…¸ä¼šåŒæ—¶æ“ä½œ(delete,find,update)ä¸¤ä¸ªhashè¡¨ã€‚ å¦‚ï¼š1234567891011121314151617dictEntry *dictFind(dict *d, const void *key)&#123; dictEntry *he; unsigned int h, idx, table; // å­—å…¸ï¼ˆçš„å“ˆå¸Œè¡¨ï¼‰ä¸ºç©º if (d-&gt;ht[0].size == 0) return NULL; /* We don't have a table at all */ // å¦‚æœæ¡ä»¶å…è®¸çš„è¯ï¼Œè¿›è¡Œå•æ­¥ rehash if (dictIsRehashing(d)) _dictRehashStep(d);//ï¼ï¼ï¼ï¼ï¼ï¼æ³¨æ„åœ¨è¿™é‡Œè¿›è¡Œäº†rehashå•æ­¥æ“ä½œ // è®¡ç®—é”®çš„å“ˆå¸Œå€¼ h = dictHashKey(d, key); // åœ¨å­—å…¸çš„å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾è¿™ä¸ªé”® // T = O(1) //........ç­‰ç­‰&#125; ç»“å°¾å­—å…¸éƒ¨åˆ†å°±è¯¦è§£å®Œæ¯•äº†ï¼Œå¦‚æœåç»­æœ‰è¡¥å……ï¼Œä¼šåœ¨æœ¬æ–‡è¿›è¡Œä¿®æ”¹æ·»åŠ ï¼Œæ¬¢è¿å…³æ³¨å“¦~~]]></content>
      <categories>
        <category>redis</category>
        <category>å¸¦ä½ ææ‡‚redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-adlist - å¸¦ä½ ææ‡‚redis]]></title>
    <url>%2Fpost%2F6622af18.html</url>
    <content type="text"><![CDATA[AdlistlistNode123456789101112typedef struct listNode &#123; // å‰ç½®èŠ‚ç‚¹ struct listNode *prev; // åç½®èŠ‚ç‚¹ struct listNode *next; // èŠ‚ç‚¹çš„å€¼ void *value;&#125; listNode; åŒç«¯é“¾è¡¨ç»“æ„ list123456789101112131415161718192021222324/* * åŒç«¯é“¾è¡¨ç»“æ„ */typedef struct list &#123; // è¡¨å¤´èŠ‚ç‚¹ listNode *head; // è¡¨å°¾èŠ‚ç‚¹ listNode *tail; // èŠ‚ç‚¹å€¼å¤åˆ¶å‡½æ•° void *(*dup)(void *ptr); // èŠ‚ç‚¹å€¼é‡Šæ”¾å‡½æ•° void (*free)(void *ptr); // èŠ‚ç‚¹å€¼å¯¹æ¯”å‡½æ•° int (*match)(void *ptr, void *key); // é“¾è¡¨æ‰€åŒ…å«çš„èŠ‚ç‚¹æ•°é‡ unsigned long len;&#125; list; listCreate123456789101112131415161718192021222324/* * åˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨ * * åˆ›å»ºæˆåŠŸè¿”å›é“¾è¡¨ï¼Œå¤±è´¥è¿”å› NULL ã€‚ * * T = O(1) */list *listCreate(void)&#123; struct list *list; // åˆ†é…å†…å­˜ if ((list = zmalloc(sizeof(*list))) == NULL) return NULL; // åˆå§‹åŒ–å±æ€§ list-&gt;head = list-&gt;tail = NULL; list-&gt;len = 0; list-&gt;dup = NULL; list-&gt;free = NULL; list-&gt;match = NULL; return list;&#125; listAddNodeHead12345678910111213141516171819202122232425262728293031323334353637383940414243/* Add a new node to the list, to head, contaning the specified 'value' * pointer as value. * * On error, NULL is returned and no operation is performed (i.e. the * list remains unaltered). * On success the 'list' pointer you pass to the function is returned. *//* * å°†ä¸€ä¸ªåŒ…å«æœ‰ç»™å®šå€¼æŒ‡é’ˆ value çš„æ–°èŠ‚ç‚¹æ·»åŠ åˆ°é“¾è¡¨çš„è¡¨å¤´ * * å¦‚æœä¸ºæ–°èŠ‚ç‚¹åˆ†é…å†…å­˜å‡ºé”™ï¼Œé‚£ä¹ˆä¸æ‰§è¡Œä»»ä½•åŠ¨ä½œï¼Œä»…è¿”å› NULL * * å¦‚æœæ‰§è¡ŒæˆåŠŸï¼Œè¿”å›ä¼ å…¥çš„é“¾è¡¨æŒ‡é’ˆ * * T = O(1) */list *listAddNodeHead(list *list, void *value)&#123; listNode *node; // ä¸ºèŠ‚ç‚¹åˆ†é…å†…å­˜ if ((node = zmalloc(sizeof(*node))) == NULL) return NULL; // ä¿å­˜å€¼æŒ‡é’ˆ node-&gt;value = value; // æ·»åŠ èŠ‚ç‚¹åˆ°ç©ºé“¾è¡¨ if (list-&gt;len == 0) &#123; list-&gt;head = list-&gt;tail = node; node-&gt;prev = node-&gt;next = NULL; // æ·»åŠ èŠ‚ç‚¹åˆ°éç©ºé“¾è¡¨ &#125; else &#123; node-&gt;prev = NULL; node-&gt;next = list-&gt;head; list-&gt;head-&gt;prev = node; list-&gt;head = node; &#125; // æ›´æ–°é“¾è¡¨èŠ‚ç‚¹æ•° list-&gt;len++; return list;&#125; è‹¥å¹²å‡½æ•°123456789101112list *listAddNodeTail(list *list, void *value);list *listInsertNode(list *list, listNode *old_node, void *value, int after);void listDelNode(list *list, listNode *node);listIter *listGetIterator(list *list, int direction);listNode *listNext(listIter *iter);void listReleaseIterator(listIter *iter);list *listDup(list *orig);listNode *listSearchKey(list *list, void *key);listNode *listIndex(list *list, long index);void listRewind(list *list, listIter *li);void listRewindTail(list *list, listIter *li);void listRotate(list *list);]]></content>
      <categories>
        <category>redis</category>
        <category>å¸¦ä½ ææ‡‚redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-sds - å¸¦ä½ ææ‡‚redis]]></title>
    <url>%2Fpost%2F9b1040fb.html</url>
    <content type="text"><![CDATA[Sdssdshdr ä¿å­˜å­—ç¬¦ä¸²å¯¹è±¡çš„ç»“æ„1234567891011121314/* * ä¿å­˜å­—ç¬¦ä¸²å¯¹è±¡çš„ç»“æ„ */struct sdshdr &#123; // buf ä¸­å·²å ç”¨ç©ºé—´çš„é•¿åº¦ int len; // buf ä¸­å‰©ä½™å¯ç”¨ç©ºé—´çš„é•¿åº¦ int free; // æ•°æ®ç©ºé—´ char buf[];&#125;; sdsnewlen12345678910111213141516171819202122232425262728293031sds sdsnewlen(const void *init, size_t initlen) &#123; struct sdshdr *sh; // æ ¹æ®æ˜¯å¦æœ‰åˆå§‹åŒ–å†…å®¹ï¼Œé€‰æ‹©é€‚å½“çš„å†…å­˜åˆ†é…æ–¹å¼ // T = O(N) if (init) &#123; // zmalloc ä¸åˆå§‹åŒ–æ‰€åˆ†é…çš„å†…å­˜ sh = zmalloc(sizeof(struct sdshdr)+initlen+1); &#125; else &#123; // zcalloc å°†åˆ†é…çš„å†…å­˜å…¨éƒ¨åˆå§‹åŒ–ä¸º 0 sh = zcalloc(sizeof(struct sdshdr)+initlen+1); &#125; // å†…å­˜åˆ†é…å¤±è´¥ï¼Œè¿”å› if (sh == NULL) return NULL; // è®¾ç½®åˆå§‹åŒ–é•¿åº¦ sh-&gt;len = initlen; // æ–° sds ä¸é¢„ç•™ä»»ä½•ç©ºé—´ sh-&gt;free = 0; // å¦‚æœæœ‰æŒ‡å®šåˆå§‹åŒ–å†…å®¹ï¼Œå°†å®ƒä»¬å¤åˆ¶åˆ° sdshdr çš„ buf ä¸­ // T = O(N) if (initlen &amp;&amp; init) memcpy(sh-&gt;buf, init, initlen); // ä»¥ \0 ç»“å°¾ sh-&gt;buf[initlen] = '\0'; // è¿”å› buf éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯æ•´ä¸ª sdshdr return (char*)sh-&gt;buf;&#125; sdsempty åˆ›å»ºä¸€ä¸ªåªåŒ…å«â€â€çš„sds123sds sdsempty(void) &#123; return sdsnewlen("",0);&#125; sdsnew12345/* Create a new sds string starting from a null termined C string. */sds sdsnew(const char *init) &#123; size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);&#125; sdsfree1234567891011/* * é‡Šæ”¾ç»™å®šçš„ sds * * å¤æ‚åº¦ * T = O(N) *//* Free an sds string. No operation is performed if 's' is NULL. */void sdsfree(sds s) &#123; if (s == NULL) return; zfree(s-sizeof(struct sdshdr));&#125; sdsclear ä¸é‡Šæ”¾sdsçš„å‰æä¸‹é‡ç½®sds123456789101112void sdsclear(sds s) &#123; // å–å‡º sdshdr struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); // é‡æ–°è®¡ç®—å±æ€§ sh-&gt;free += sh-&gt;len; sh-&gt;len = 0; // å°†ç»“æŸç¬¦æ”¾åˆ°æœ€å‰é¢ï¼ˆç›¸å½“äºæƒ°æ€§åœ°åˆ é™¤ buf ä¸­çš„å†…å®¹ï¼‰ sh-&gt;buf[0] = '\0';&#125; sdsMakeRoomFor ç»™så¢åŠ å†…å­˜ï¼Œè‹¥æœ¬åœ°å€çš„å†…å­˜ä¸è¶³ï¼Œå¦‚æœæ–°é•¿åº¦å°äºSDS_MAX_PREALLOCï¼Œ åˆ™å˜æˆäºŒå€ï¼Œå¦åˆ™åŠ ä¸ŠSDS_MAX_PREALLOCï¼Œè¿™é‡Œä¸»è¦æ˜¯ä¸ºäº†é¿å…é‡å¤æ‰©å®¹é€ æˆçš„æµªè´¹123456789101112131415161718192021222324252627282930313233343536373839sds sdsMakeRoomFor(sds s, size_t addlen) &#123; struct sdshdr *sh, *newsh; // è·å– s ç›®å‰çš„ç©ºä½™ç©ºé—´é•¿åº¦ size_t free = sdsavail(s); size_t len, newlen; // s ç›®å‰çš„ç©ºä½™ç©ºé—´å·²ç»è¶³å¤Ÿï¼Œæ— é¡»å†è¿›è¡Œæ‰©å±•ï¼Œç›´æ¥è¿”å› if (free &gt;= addlen) return s; // è·å– s ç›®å‰å·²å ç”¨ç©ºé—´çš„é•¿åº¦ len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); // s æœ€å°‘éœ€è¦çš„é•¿åº¦ newlen = (len+addlen); // æ ¹æ®æ–°é•¿åº¦ï¼Œä¸º s åˆ†é…æ–°ç©ºé—´æ‰€éœ€çš„å¤§å° if (newlen &lt; SDS_MAX_PREALLOC) // å¦‚æœæ–°é•¿åº¦å°äº SDS_MAX_PREALLOC // é‚£ä¹ˆä¸ºå®ƒåˆ†é…ä¸¤å€äºæ‰€éœ€é•¿åº¦çš„ç©ºé—´ newlen *= 2; else // å¦åˆ™ï¼Œåˆ†é…é•¿åº¦ä¸ºç›®å‰é•¿åº¦åŠ ä¸Š SDS_MAX_PREALLOC newlen += SDS_MAX_PREALLOC; // T = O(N) newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); // å†…å­˜ä¸è¶³ï¼Œåˆ†é…å¤±è´¥ï¼Œè¿”å› if (newsh == NULL) return NULL; // æ›´æ–° sds çš„ç©ºä½™é•¿åº¦ newsh-&gt;free = newlen - len; // è¿”å› sds return newsh-&gt;buf;&#125; å¦‚ä½•é€šè¿‡sdshdrçš„bufæ¥æ‰¾åˆ°sdshdrçš„æŒ‡é’ˆ1struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));]]></content>
      <categories>
        <category>redis</category>
        <category>å¸¦ä½ ææ‡‚redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-memory - å¸¦ä½ ææ‡‚redis]]></title>
    <url>%2Fpost%2F6f0279ba.html</url>
    <content type="text"><![CDATA[zmalloc1234567891011121314151617/** åŠ¨æ€åˆ†é…å¤§å°ä¸ºsizeçš„å†…å­˜å¹¶è¿”å›æŒ‡é’ˆ*/void *zmalloc(size_t size) &#123; void *ptr = malloc(size+PREFIX_SIZE); if (!ptr) zmalloc_oom_handler(size); //æ‰“å°é”™è¯¯ä¿¡æ¯å¹¶ç»ˆæ­¢ç¨‹åº#ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr;#else *((size_t*)ptr) = size; //è¿™é‡Œæ˜¯ä¿è¯å†…å­˜ç»Ÿè®¡æ­£ç¡® å› ä¸ºmallocä¼š8å­—èŠ‚å¯¹é½ update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE;#endif&#125; zcalloc12345678910111213141516/** åˆ†é…å†…å­˜ calloc åˆ†é…çš„æ—¶å€™ä¼šåˆå§‹åŒ–*/void *zcalloc(size_t size) &#123; void *ptr = calloc(1, size+PREFIX_SIZE); if (!ptr) zmalloc_oom_handler(size);#ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr;#else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE;#endif&#125; zcalloc å’Œ zmalloc çš„åŒºåˆ«åœ¨äºzcallocåˆå§‹åŒ–äº†å†…å­˜ï¼Œå„¿zmallocæ²¡æœ‰ zrealloc12345678910111213141516171819202122232425262728void *zrealloc(void *ptr, size_t size) &#123;#ifndef HAVE_MALLOC_SIZE void *realptr;#endif size_t oldsize; void *newptr; if (ptr == NULL) return zmalloc(size);#ifdef HAVE_MALLOC_SIZE oldsize = zmalloc_size(ptr); newptr = realloc(ptr,size); if (!newptr) zmalloc_oom_handler(size); update_zmalloc_stat_free(oldsize); update_zmalloc_stat_alloc(zmalloc_size(newptr)); return newptr;#else realptr = (char*)ptr-PREFIX_SIZE; oldsize = *((size_t*)realptr); newptr = realloc(realptr,size+PREFIX_SIZE); if (!newptr) zmalloc_oom_handler(size); *((size_t*)newptr) = size; update_zmalloc_stat_free(oldsize); update_zmalloc_stat_alloc(size); return (char*)newptr+PREFIX_SIZE;#endif&#125; zfree12345678910111213141516171819void zfree(void *ptr) &#123;#ifndef HAVE_MALLOC_SIZE void *realptr; size_t oldsize;#endif if (ptr == NULL) return;#ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_free(zmalloc_size(ptr)); free(ptr); #else//æ²¡æœ‰å†…ç½®mallocå‡½æ•° realptr = (char*)ptr-PREFIX_SIZE; oldsize = *((size_t*)realptr); update_zmalloc_stat_free(oldsize+PREFIX_SIZE); free(realptr);#endif&#125; æ³¨æ„HAVE_MALLOC_SIZEè¿™ä¸ªå¸¸é‡ä»£è¡¨äº†ç³»ç»Ÿæ˜¯å¦æœ‰å¯mallocï¼Œå¦‚æœæ²¡æœ‰çš„è¯éœ€è¦è‡ªå·±æ‰‹åŠ¨æ¥æ±‚æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜çš„å¤§å°ï¼Œæ‰€ä»¥ä¸Šé¢å‡½æ•°éƒ½æœ‰ä¸¤ç§æƒ…å†µã€‚]]></content>
      <categories>
        <category>redis</category>
        <category>å¸¦ä½ ææ‡‚redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>source code</tag>
      </tags>
  </entry>
</search>
